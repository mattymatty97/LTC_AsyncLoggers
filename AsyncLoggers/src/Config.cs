using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using BepInEx;
using BepInEx.Configuration;
using BepInEx.Logging;
using File = System.IO.File;

namespace AsyncLoggers;

using System;
using System.Xml;

internal static class XmlConfig
{
    private static readonly string XMLFilename = Utility.CombinePaths(Paths.ConfigPath, AsyncLoggers.NAME, "LogLines.xml");
    private const string ConfigVersion = "v1";
    
    private const string RootComment =
        """
        THIS FILE IS AUTOGENERATED. PLEASE BE CAUTIOUS WHEN MAKING CHANGES.
            - The "default_status" attribute specifies the default behavior when a log call's "status" is set to "Default" or is invalid.
        """;
    private const string UsageComment =
        """
        Here’s an explanation of this configuration format:

        1.  **File Structure**:
            - **Assembly**: Represents the assembly (e.g., 'Assembly-CSharp').
            - **Class**: Represents the class within the assembly (e.g., 'BaboonBirdAI').
            - **Method**: Represents the method within the class (e.g., 'DropHeldItemAndSync').

        2.  **User-Editable Entries**:
            - Entries you can modify are marked as `<LogCall>`.
            - Each `<LogCall>` element contains:
              - The pseudo-code of the log call.
              - An attribute called `status`.

        3.  **Status Attribute**:
            - `status="Unity"`: No changes from the original code.
            - `status="BepInEx"`: Log call is redirected using the BepInEx logger (non-blocking thanks to this mod).
            - `status="Suppressed"`: Log call is removed and nothing will be printed.
           
        3.1 **Default Status Attribute**:
            - The first element of this file has a "default_status" attribute (`<Configuration default_status="Unity">`)
            - Edit it to change the behavior of all `status="Default"` entries

        4.  **Cooldown Attribute** (only applicable if `status="BepInEx"`):
            - An optional "cooldown" attribute may be added to limit how often the log messages can appear. (Value in milliseconds).
            - Example: `<LogCall status="BepInEx" cooldown="500">LogError("Error message")</LogCall>`
           
        4.1 **Cooldown Attribute Warning**
            - Please use this attribute with care as complex loglines might not work or crash when using it!

        **Important**:
        - All attribute values must be enclosed in quotes.
        """;
    private const string EditReminderComment = 
        """
        Edit 'status' to customize log behavior
        """;

    private static bool _fileChanged = false;
    
    internal struct LogCallInfo
    {
        public string AssemblyName { get; }
        public string ClassName { get; }
        public string MethodName { get; }
        public string LogLine { get; }

        public readonly CallStatus Status => _status != CallStatus.Default ? _status : DefaultStatus;

        public int? Cooldown { get; }

        private LogCallInfo(string assemblyName, string className, string methodName, string logLine, CallStatus status,
            int? cooldown)
        {
            AssemblyName = assemblyName;
            ClassName = className;
            MethodName = methodName;
            LogLine = logLine;
            _status = status;
            Cooldown = cooldown;
        }

        internal static LogCallInfo GetOrAdd(string assemblyName, string className, string methodName, string logLine)
        {
            var doc = PluginConfig.LogConfig; // Assuming PluginConfig.LogConfig is an XmlDocument
            var root = doc.DocumentElement;

            // Find or create the Assembly node
            XmlNode assemblyNode = root!.SelectSingleNode($"Assembly[@name='{assemblyName}']");
            if (assemblyNode == null)
            {
                assemblyNode = doc.CreateElement("Assembly");
                var assemblyAttr = doc.CreateAttribute("name");
                assemblyAttr.Value = assemblyName;
                ((XmlElement)assemblyNode).SetAttributeNode(assemblyAttr);
                root.AppendChild(assemblyNode);
                _fileChanged = true;
            }

            // Find or create the Class node
            XmlNode classNode = assemblyNode.SelectSingleNode("Class[@name='" + className + "']");
            if (classNode == null)
            {
                classNode = doc.CreateElement("Class");
                var classAttr = doc.CreateAttribute("name");
                classAttr.Value = className;
                ((XmlElement)classNode).SetAttributeNode(classAttr);
                assemblyNode.AppendChild(classNode);
                _fileChanged = true;
            }

            // Find or create the Method node
            XmlNode methodNode = classNode.SelectSingleNode("Method[@name='" + methodName + "']");
            if (methodNode == null)
            {
                methodNode = doc.CreateElement("Method");
                var methodAttr = doc.CreateAttribute("name");
                methodAttr.Value = methodName;
                ((XmlElement)methodNode).SetAttributeNode(methodAttr);
                classNode.AppendChild(methodNode);
                
                XmlComment reminderComment =
                    doc.CreateComment(EditReminderComment);

                methodNode.AppendChild(reminderComment);
                _fileChanged = true;
            }

            // Find or create the LogCall node
            XmlNode logCallNode = null;
            foreach (XmlNode node in methodNode!.SelectNodes("LogCall")!)
            {
                if (node.InnerText.Trim() == logLine.Trim())
                {
                    logCallNode = node;
                    break;
                }
            }

            if (logCallNode == null)
            {
                // Create new LogCall element
                logCallNode = doc.CreateElement("LogCall");
                var statusAttr = doc.CreateAttribute("status");
                statusAttr.Value = "Default";
                ((XmlElement)logCallNode).SetAttributeNode(statusAttr);
                logCallNode.InnerText = logLine;
                methodNode.AppendChild(logCallNode);
                _fileChanged = true;
            }

            // Parse the status and delay attributes
            var statusAttrValue = ((XmlElement)logCallNode).GetAttribute("status");
            if (!Enum.TryParse(statusAttrValue ?? "Default", out CallStatus status))
                status = CallStatus.Default;

            int? delay = null;
            var delayAttrValue = ((XmlElement)logCallNode).GetAttribute("cooldown");
            if (!delayAttrValue.IsNullOrWhiteSpace())
            {
                if (int.TryParse(delayAttrValue, out var parsedDelay))
                    delay = parsedDelay;
                else
                    delay = 1000; // Default value if parsing fails
            }

            return new LogCallInfo(assemblyName, className, methodName, logLine, status, delay);
        }

        internal static CallStatus DefaultStatus = CallStatus.Unity;
        private readonly CallStatus _status;

    }
    
    internal static void InitLogConfig()
    {
        const string versionString = $"{AsyncLoggers.NAME} {ConfigVersion}";

        // Initialize XmlDocument
        var configFile = PluginConfig.LogConfig = new XmlDocument();

        if (File.Exists(XMLFilename))
        {
            // Load existing XML file
            configFile.Load(XMLFilename);
        }

        if (configFile.DocumentElement != null)
        {
            var version = configFile.DocumentElement.GetAttribute("version");
            if (version != versionString)
            {
                AsyncLoggers.Log.LogError($"Old Config version detected: found '{version}' but we're using '{versionString}'");
                //TODO handle old config version!
            }
        }
        
        if(configFile.DocumentElement == null)
        {
            // Create the XML declaration with version and encoding
            XmlDeclaration xmlDeclaration = configFile.CreateXmlDeclaration("1.0", "UTF-8", null);
            configFile.AppendChild(xmlDeclaration);
            
            // Create new XML document with root element
            var root = configFile.CreateElement("Configuration");
            var attr1 = configFile.CreateAttribute("version");
            attr1.Value = versionString;
            root.SetAttributeNode(attr1);
            
            var attr2 = configFile.CreateAttribute("default_status");
            attr2.Value = LogCallInfo.DefaultStatus.ToString();
            root.SetAttributeNode(attr2);
            
            var rootCommentNode = configFile.CreateComment(RootComment);
            configFile.AppendChild(rootCommentNode);
            
            configFile.AppendChild(root);
            
            var usageCommentNode = configFile.CreateComment(UsageComment);
            root.AppendChild(usageCommentNode);
            _fileChanged = true;
        }

        if (Enum.TryParse(configFile.DocumentElement!.GetAttribute("default_status"), out CallStatus defaultStatus) && defaultStatus != CallStatus.Default)
        {
            LogCallInfo.DefaultStatus = defaultStatus;
        }
        
    }

    internal static void WriteLogConfig()
    {
        // Write to the file
        if (!_fileChanged) 
            return;

        using var writer = new XmlTextWriter(XMLFilename, Encoding.UTF8);
        writer.Formatting = Formatting.Indented;
        PluginConfig.LogConfig.WriteContentTo(writer);
    }

    internal enum CallStatus
    {
        Default,
        Unity,
        BepInEx,
        Suppressed
    }
}

internal static class FilterConfig
{
    internal static readonly ConcurrentDictionary<ILogSource, LogLevel> LevelMasks = [];

    private static LogLevel GetListenerConfig(ILogSource source)
    {
        var sourceName = source.SourceName.Trim();

        var sectionName = Regex.Replace(sourceName, @"[\n\t\\\'[\]]", "");

        var enabled = PluginConfig.FilterConfig.Bind(sectionName, "Enabled", true,
            new ConfigDescription("Allow source to write logs"));

        var logLevel = PluginConfig.FilterConfig.Bind(sectionName, "LogLevels", LogLevel.All,
            new ConfigDescription("What levels to write"));

        return enabled.Value ? logLevel.Value : LogLevel.None;
    }

    internal static LogLevel GetMaskForSource(ILogSource source)
    {
        return LevelMasks.GetOrAdd(source, GetListenerConfig);
    }
}

[SuppressMessage("ReSharper", "MemberHidesStaticFromOuterClass")]
internal static class PluginConfig
{
    private static ConfigFile _config;
    internal static ConfigFile FilterConfig;
    internal static XmlDocument LogConfig;

    

    internal static void Init()
    {
        _config = new ConfigFile(Utility.CombinePaths(Paths.ConfigPath, AsyncLoggers.NAME, "Config.cfg"), true);
        FilterConfig = new ConfigFile(Utility.CombinePaths(Paths.ConfigPath, AsyncLoggers.NAME, "LogLevels.cfg"), true);
        XmlConfig.InitLogConfig();

        //Initialize Configs
        //Timestamps
        Timestamps.Enabled = _config.Bind("Timestamps", "Enabled", true
            , "add numeric timestamps to the logs");
        Timestamps.Type = _config.Bind("Timestamps", "Type", TimestampType.DateTime
            , "what kind of timestamps to use");
        //DbLogger
        DbLogger.Enabled = _config.Bind("DbLogger", "Enabled", true
            , "flush logs to a Sqlite database");
        DbLogger.RotationSize = _config.Bind("DbLogger", "Min file size for rotation", 100000000L
            , "how big the file can grow before it is rotated ( in bytes )");
        //Scheduler
        Scheduler.ThreadBufferSize = _config.Bind("Scheduler", "Buffer max size", 500U
            , "maximum size of the log queue for the Threaded Scheduler ( each logger has a separate one )");
        Scheduler.ShutdownType = _config.Bind("Scheduler", "Shutdown style", ShutdownType.Await
            , "close immediately or wait for all logs to be written ( Instant/Await ) ");
        //BepInEx
        BepInEx.Disk = _config.Bind("BepInEx", "Async File", true
            , "convert BepInEx disk writer to async");
        BepInEx.Console = _config.Bind("BepInEx", "Async Console", true
            , "convert BepInEx console to async");
        BepInEx.Unity = _config.Bind("BepInEx", "Async Unity", true
            , "convert BepInEx->Unity Log to async");
        //Debug
        Debug.VerboseCecil = _config.Bind("Debug", "VerboseCecil", false, "Print A LOT more logs about LogLine tracking");

        CleanOrphanedEntries(_config);
    }

    internal static void CleanOrphanedEntries(ConfigFile config)
    {
        //remove unused options
        var orphanedEntriesProp =
            config.GetType().GetProperty("OrphanedEntries", BindingFlags.NonPublic | BindingFlags.Instance);

        var orphanedEntries = (Dictionary<ConfigDefinition, string>)orphanedEntriesProp!.GetValue(config, null);

        orphanedEntries.Clear(); // Clear orphaned entries (Unbinded/Abandoned entries)
        config.Save(); // Save the config file
    }

    public static class Scheduler
    {
        public static ConfigEntry<uint> ThreadBufferSize;
        public static ConfigEntry<ShutdownType> ShutdownType;
    }

    public static class DbLogger
    {
        public static ConfigEntry<bool> Enabled;
        public static ConfigEntry<long> RotationSize;
    }

    public static class Timestamps
    {
        public static ConfigEntry<bool> Enabled;
        public static ConfigEntry<TimestampType> Type;
    }

    public static class BepInEx
    {
        public static ConfigEntry<bool> Console;
        public static ConfigEntry<bool> Disk;
        public static ConfigEntry<bool> Unity;
    }

    public static class Debug
    {
        public static ConfigEntry<bool> VerboseCecil;
    }

    public enum ShutdownType
    {
        Instant,
        Await
    }

    public enum TimestampType
    {
        DateTime,
        TickCount,
        Counter
    }
}