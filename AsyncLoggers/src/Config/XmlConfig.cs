using System;
using System.IO;
using System.Security;
using System.Text;
using System.Xml;
using BepInEx;

namespace AsyncLoggers.Config;

internal static class XmlConfig
{
    private static readonly string XMLFilename =
        Utility.CombinePaths(Paths.ConfigPath, AsyncLoggers.NAME, "LogLines.xml");

    private const string ConfigVersion = "v1";

    private const string RootComment =
        """
        THIS FILE IS AUTOGENERATED. PLEASE BE CAUTIOUS WHEN MAKING CHANGES.
            - The "default_status" attribute specifies the default behavior when a log call's "status" is set to "Default" or is invalid.
            - **WARNING** Changing the default might increase boot times!
        """;

    private const string UsageComment =
        """
        Here’s an explanation of this configuration format:

        1.  **File Structure**:
            - **Assembly**: Represents an assembly (e.g., 'Assembly-CSharp').
            - **Class**: Represents a class within the assembly (e.g., 'BaboonBirdAI').
            - **Method**: Represents a method within the class (e.g., 'DropHeldItemAndSync').

        2.  **User-Editable Entries**:
            - Entries you can modify are marked as `<LogCall>`.
            - Each `<LogCall>` element contains:
              - The pseudo-code of the log call.
              - An attribute called `status`.

        3.  **Status Attribute**:
            - `status="Unity"`: No changes from the original code.
            - `status="BepInEx"`: Log call is redirected using the BepInEx logger (non-blocking thanks to this mod).
            - `status="Suppressed"`: Log call is removed and nothing will be printed.
           
        3.1 **Default Status Attribute**:
            - The first element of this file has a "default_status" attribute (`<Configuration default_status="Unity">`)
            - Edit it to change the behavior of all `status="Default"` entries

        4.  **Cooldown Attribute** (only applicable if `status="BepInEx"`):
            - An optional "cooldown" attribute may be added to limit how often the log messages can appear. (Value in milliseconds).
            - Example: `<LogCall status="BepInEx" cooldown="500">LogError("Error message")</LogCall>`
           
        4.1 **Cooldown Attribute Warning**
            - Please use this attribute with care as complex loglines might not work or crash when using it!

        **Important**:
        - All attribute values must be enclosed in quotes.
        """;

    private const string EditReminderComment =
        """
        Edit 'status' to customize log behavior
        """;

    internal struct LogCallInfo
    {
        public string AssemblyName { get; }
        public string ClassName { get; }
        public string MethodName { get; }
        public string LogLine { get; }

        public readonly CallStatus Status => _status != CallStatus.Default ? _status : DefaultStatus;

        public int? Cooldown { get; }

        private LogCallInfo(string assemblyName, string className, string methodName, string logLine, CallStatus status,
            int? cooldown)
        {
            AssemblyName = assemblyName;
            ClassName = className;
            MethodName = methodName;
            LogLine = logLine;
            _status = status;
            Cooldown = cooldown;
        }

        internal static LogCallInfo GetOrAdd(string assemblyName, string className, string methodName, string logLine)
        {
            var doc = PluginConfig.LogConfig; // Assuming PluginConfig.LogConfig is an XmlDocument
            var root = doc.DocumentElement;

            // Find or create the Assembly node
            XmlNode assemblyNode = root!.SelectSingleNode($"Assembly[@name='{assemblyName}']");
            if (assemblyNode == null)
            {
                assemblyNode = doc.CreateElement("Assembly");
                var assemblyAttr = doc.CreateAttribute("name");
                assemblyAttr.Value = assemblyName;
                ((XmlElement)assemblyNode).SetAttributeNode(assemblyAttr);
                root.AppendChild(assemblyNode);
            }

            UnMarkAsObsolete(assemblyNode);

            // Find or create the Class node
            XmlNode classNode = assemblyNode.SelectSingleNode("Class[@name='" + className + "']");
            if (classNode == null)
            {
                classNode = doc.CreateElement("Class");
                var classAttr = doc.CreateAttribute("name");
                classAttr.Value = className;
                ((XmlElement)classNode).SetAttributeNode(classAttr);
                assemblyNode.AppendChild(classNode);
            }

            UnMarkAsObsolete(classNode);

            // Find or create the Method node
            XmlNode methodNode = classNode.SelectSingleNode("Method[@name='" + methodName + "']");
            if (methodNode == null)
            {
                methodNode = doc.CreateElement("Method");
                var methodAttr = doc.CreateAttribute("name");
                methodAttr.Value = methodName;
                ((XmlElement)methodNode).SetAttributeNode(methodAttr);
                classNode.AppendChild(methodNode);

                XmlComment reminderComment =
                    doc.CreateComment(EditReminderComment);

                methodNode.AppendChild(reminderComment);
            }

            UnMarkAsObsolete(methodNode);

            // Find or create the LogCall node
            XmlNode logCallNode = null;
            foreach (XmlNode node in methodNode!.SelectNodes("LogCall")!)
            {
                if (node.InnerText.Trim() == logLine.Trim())
                {
                    logCallNode = node;
                    break;
                }
            }

            if (logCallNode == null)
            {
                // Create new LogCall element
                logCallNode = doc.CreateElement("LogCall");
                var statusAttr = doc.CreateAttribute("status");
                statusAttr.Value = "Default";
                ((XmlElement)logCallNode).SetAttributeNode(statusAttr);
                logCallNode.InnerText = logLine;
                methodNode.AppendChild(logCallNode);
            }

            UnMarkAsObsolete(logCallNode);

            // Parse the status and delay attributes
            var statusAttrValue = ((XmlElement)logCallNode).GetAttribute("status");
            if (!Enum.TryParse(statusAttrValue ?? "Default", out CallStatus status))
                status = CallStatus.Default;

            int? delay = null;
            var delayAttrValue = ((XmlElement)logCallNode).GetAttribute("cooldown");
            if (!delayAttrValue.IsNullOrWhiteSpace())
            {
                if (int.TryParse(delayAttrValue, out var parsedDelay))
                    delay = parsedDelay;
                else
                    delay = 1000; // Default value if parsing fails
            }

            return new LogCallInfo(assemblyName, className, methodName, logLine, status, delay);
        }

        internal static CallStatus DefaultStatus = CallStatus.Unity;
        private readonly CallStatus _status;
    }

    internal static void InitLogConfig()
    {
        const string versionString = $"{AsyncLoggers.NAME} {ConfigVersion}";

        // Initialize XmlDocument
        var configFile = PluginConfig.LogConfig = new XmlDocument();

        if (File.Exists(XMLFilename))
        {
            // Load existing XML file
            configFile.Load(XMLFilename);
        }

        if (configFile.DocumentElement != null)
        {
            var version = configFile.DocumentElement.GetAttribute("version");
            if (version != versionString)
            {
                AsyncLoggers.Log.LogError(
                    $"Old Config version detected: found '{version}' but we're using '{versionString}'");
                //TODO handle old config version!
            }
        }

        if (configFile.DocumentElement == null)
        {
            // Create the XML declaration with version and encoding
            XmlDeclaration xmlDeclaration = configFile.CreateXmlDeclaration("1.0", "UTF-8", null);
            configFile.AppendChild(xmlDeclaration);

            // Create new XML document with root element
            var root = configFile.CreateElement("Configuration");
            var attr1 = configFile.CreateAttribute("version");
            attr1.Value = versionString;
            root.SetAttributeNode(attr1);

            var attr2 = configFile.CreateAttribute("default_status");
            attr2.Value = LogCallInfo.DefaultStatus.ToString();
            root.SetAttributeNode(attr2);

            var rootCommentNode = configFile.CreateComment(RootComment);
            configFile.AppendChild(rootCommentNode);

            configFile.AppendChild(root);

            var usageCommentNode = configFile.CreateComment(UsageComment);
            root.AppendChild(usageCommentNode);
        }

        if (Enum.TryParse(configFile.DocumentElement!.GetAttribute("default_status"), out CallStatus defaultStatus) &&
            defaultStatus != CallStatus.Default)
        {
            LogCallInfo.DefaultStatus = defaultStatus;
        }

        // Recursively add or update the attribute in all child nodes
        foreach (XmlNode childNode in configFile.DocumentElement.ChildNodes)
        {
            MarkAllAsObsolete(childNode);
        }
    }

    internal static void WriteLogConfig()
    {
        if (!PluginConfig.LogWrapping.Enabled.Value)
            return;

        // Write to the file
        using var writer = new XmlTextWriter(XMLFilename, Encoding.UTF8);
        writer.Formatting = Formatting.Indented;
        PluginConfig.LogConfig.WriteContentTo(writer);
    }

    private static void MarkAllAsObsolete(XmlNode node)
    {
        // Check if the node is an element and can have attributes
        if (node.NodeType == XmlNodeType.Element && node.Attributes != null)
        {
            // Create the "obsolete" attribute
            var obsoleteAttribute = node.OwnerDocument!.CreateAttribute("obsolete");
            obsoleteAttribute.Value = "true";

            // Temporarily store the existing attributes
            var existingAttributes = new XmlAttribute[node.Attributes.Count];
            node.Attributes.CopyTo(existingAttributes, 0);

            // Remove all existing attributes
            node.Attributes.RemoveAll();

            // Add the "obsolete" attribute as the first one
            node.Attributes.Append(obsoleteAttribute);

            // Re-add the original attributes
            foreach (var attr in existingAttributes)
            {
                if (attr.Name != "obsolete")
                {
                    node.Attributes.Append(attr);
                }
            }
        }

        // Recursively add or update the attribute in all child nodes
        foreach (XmlNode childNode in node.ChildNodes)
        {
            MarkAllAsObsolete(childNode);
        }
    }

    private static void UnMarkAsObsolete(XmlNode node)
    {
        // Check if the node is an element and can have attributes
        if (node.NodeType == XmlNodeType.Element && node.Attributes != null)
        {
            // Check if the "obsolete" attribute exists
            var obsoleteAttribute = node.Attributes["obsolete"];
            if (obsoleteAttribute != null)
            {
                // Remove the "obsolete" attribute
                node.Attributes.Remove(obsoleteAttribute);
            }
        }
    }

    internal enum CallStatus
    {
        Default,
        Unity,
        BepInEx,
        Suppressed
    }
}